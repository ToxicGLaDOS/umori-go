package main

import (
	"errors"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/toxicglados/umori-go/pkg/crypto"
	"github.com/toxicglados/umori-go/pkg/models"

	"github.com/golang-jwt/jwt"

	"github.com/gin-gonic/gin"
	_ "github.com/shaj13/libcache/fifo"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

const (
	pageSize = 25
)

var (
	db *gorm.DB
	dsn = "host=localhost user=postgres password=password dbname=postgres port=55432 TimeZone=America/Chicago"
	ErrUnexpectedEOF error = errors.New("Unexpected EOF")
	ErrUserAlreadyExists error = errors.New("That username already exists")
	ErrUnknown error = errors.New("Unknown error")
	ErrCreatingToken error = errors.New("Error creating token")
	ErrInvalidJSON error = errors.New("Invalid JSON body")
	ErrInvalidCredentials error = errors.New("Invalid credentials")
	ErrMissingBasicAuth error = errors.New("Request missing BasicAuth")
	ErrMalformedToken error = errors.New("Malformed JWT token")
	ErrInvalidToken error = errors.New("Invalid JWT token")
	ErrMissingKID error = errors.New("Token missing kid header. Provided JWT likely wasn't generated by this server")
	ErrInvalidUUID error = errors.New("Invalid UUID")
	// TODO: The string "my_secret_key" is just an example and should be replaced with a secret key of sufficient length and complexity in a real-world scenario.
	jwtKey = []byte("my_secret_key")

)
func GetOffset(c *gin.Context) int {
	page, err := strconv.Atoi(c.Query("page"))
	if err != nil || page < 0 {
		page = 0
	}
	offset := page * pageSize

	return offset
}

func Paginate(c *gin.Context) func(db *gorm.DB) *gorm.DB {
	return func (db *gorm.DB) *gorm.DB {
		offset := GetOffset(c)
		c.Set("offset", int64(offset))
		return db.Offset(offset).Limit(pageSize)
	}
}

type SearchResult struct {
	PagedResult
	Cards []models.Card `json:"results"`
}

type PagedResult struct {
	HasMore bool `json:"has_more"`
}

func NewPagedResult(count, offset int64) PagedResult {
	return PagedResult {
		HasMore: count - (offset + pageSize) > 0,
	}
}

type ErrorResponse struct {
	Message string `json:"message"`
}

var (
	unauthorizedResponse ErrorResponse = ErrorResponse{Message: "Unauthorized (response)"}
)

func setupRouter() *gin.Engine {
	// Disable Console Color
	// gin.DisableConsoleColor()
	r := gin.Default()

	tokenAuthorized := r.Group("/api")
	tokenAuthorized.Use(TokenAuthRequired())
	{
		tokenAuthorized.POST("/:user/collection/:action", collectionPostEndpoint)
		tokenAuthorized.GET("/:user/collection/cards/:id", collectionGetCardsByID)
		tokenAuthorized.GET("/:user", userEndpoint)
	}

	r.GET("/api/cards/search", searchEndpoint)

	r.POST("/api/register", registerEndpoint)
	r.POST("/api/login", loginEndpoint)

	return r
}

type Claims struct {
    jwt.StandardClaims
}

// Basically just a test endpoint for now
func userEndpoint(c *gin.Context) {
	user := c.Param("user")

	obj := struct {
		Username string
	}{
		Username: user,
	}

	c.JSON(http.StatusOK, obj)
}

func loginEndpoint(c *gin.Context) {
	var form models.UnsafeUser
	// This will infer what binder to use depending on the content-type header.
	if err := c.ShouldBind(&form); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var user models.User
	db.Model(&models.User{}).Select("PasswordHash").Where("username = ?", form.Username).First(&user)
	match, err := crypto.ComparePasswordAndHash(*form.Password, user.PasswordHash)

	if match {
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"status": "error creating token"})
			return
		}

		expirationTime := time.Now().Add(5 * time.Minute)

		claims := Claims{
		    StandardClaims: jwt.StandardClaims{
		        Subject:   *form.Username,
		        ExpiresAt: expirationTime.Unix(),
		    },
		}
		token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
		tokenString, err := token.SignedString(jwtKey)
		log.Println(tokenString)
		if err != nil {
			log.Println(err.Error())
			c.JSON(http.StatusUnauthorized, gin.H{"status": "error signing token"})
			return
		}

		// gin has a c.SetCookie() function, but I don't understand
		// all the options in it and there doesn't seem to be docs
		// on exactly what they mean, so I just use this
		// TODO: Consider enabling Secure, HttpOnly, and Max-Age=<token lifespan> options
		// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie
		c.Writer.Header().Add("Set-Cookie", fmt.Sprintf("token=%s", tokenString))
		c.JSON(http.StatusOK, gin.H{"status": "you are logged in"})
		return
	} else {
		if err != nil {
			// TODO: Probably shouldn't return this error to the user directly, not sure what it includes
			c.JSON(http.StatusUnauthorized, gin.H{"status": fmt.Sprintf("unauthorized: %s", err.Error())})
		}
		c.JSON(http.StatusUnauthorized, gin.H{"status": "unauthorized (incorrect password)"})
		return
	} 
	
}

func registerEndpoint(c *gin.Context) {
		var unsafeUser models.UnsafeUser

		err := c.ShouldBind(&unsafeUser)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}
		passwordHash, err := crypto.GenerateFromPassword(*unsafeUser.Password, crypto.DefaultHashingParams())

		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
		}

		var user = models.User{
			Username: *unsafeUser.Username,
			PasswordHash: passwordHash,
		}

		//err := c.BindJSON(&user)
		//if err != nil {
		//	if errors.Is(err, io.EOF) {
		//		c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrUnexpectedEOF.Error()})
		//	} else {
		//		var unmarshalTypeError *json.UnmarshalTypeError
		//		var syntaxError *json.SyntaxError
		//		if errors.As(err, &unmarshalTypeError) {
		//			c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrInvalidJSON.Error()})
		//		} else if errors.Is(err, models.ErrMissingPassword) || errors.Is(err, models.ErrMissingUsername) || errors.As(err, &syntaxError) {	
		//			c.JSON(http.StatusBadRequest, ErrorResponse{Message: err.Error()})
		//		} else {
		//			c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrUnknown.Error()})
		//		}
		//	}
		//	return
		//}

		err = db.Create(&user).Error

		if err != nil {
			if errors.Is(err, gorm.ErrDuplicatedKey) {
				c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrUserAlreadyExists.Error()})
			} else {
				// I'm not sure what could cause this
				log.Printf("Got unexpected error during user creation: \"%s\"\n", err.Error())
				c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrUnknown.Error()})
			}
			return
		}

		c.JSON(http.StatusOK, struct{}{})
	}

func searchScope(nameContains string, defaultOnly, includeDigitalExclusive bool) func(db *gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		result := db.Model(&models.Card{}).
		             Where("name ILIKE ?", nameContains)
		if defaultOnly {
			result = result.Where("default_lang = true")
		}
		if !includeDigitalExclusive {
			result = result.Where("digital_exclusive = false")
		}
		return result
	}
}

func searchEndpoint(c *gin.Context) {
		// nameContains is never empty because of the %%
		// so even without a parameter we will search for everything
		nameContains := fmt.Sprintf("%%%s%%", c.Query("nameContains"))
		defaultOnly := c.Query("defaultOnly") == "true"
		collapsePrintings := c.Query("collapsePrintings") == "true"
		includeDigitalExclusive := c.Query("includeDigitalExclusive") == "true"

		// collapsePrintings implies defaultOnly
		if collapsePrintings {
			defaultOnly = true
		}

		// Get count for query
		var count int64
		result := db.Model(&models.Card{}).
		            Scopes(searchScope(nameContains, defaultOnly, includeDigitalExclusive))

		if collapsePrintings {
			result = result.Distinct("name")
		}
		err := result.Count(&count).
		              Error
		if err != nil {
			log.Fatal(err)
		}

		// Get rows for query
		var cards []models.Card
		result = db.Model(&models.Card{}).
		            Preload("Set").
		            Preload("Finishes").
		            Preload("Faces").
		            Scopes(searchScope(nameContains, defaultOnly, includeDigitalExclusive))

		if collapsePrintings {
			// This is a postgres exclusive trick
			result = result.Select("DISTINCT ON (name) *")
		}

		// The collector_number sorting is a bit wild
		// We check if it's a number and then cast it to a number
		// if not, then we try to find a substring that's an number
		// and cast that to a number and add a large number to
		// preserve the order of non-numeric collector_numbers while still
		// making it larger than any numeric one.
		// lastly, if there are no numbers in the collector_number we just make it a large number
		// Of course this happens after the other searches so it's rarely relevant
		result = result.Order("name").
		                Order(`
		                CASE
		                  WHEN language = 'en' THEN 0
		                  ELSE 1
		                END`).
		                Order("release_date desc").
		                Order("default_lang desc").
		                Order(`
		                CASE
		                  WHEN collector_number ~ '^[0-9]+$' THEN cast(collector_number as int)
		                  WHEN collector_number ~ '[0-9]+' THEN cast(substring(collector_number from '[0-9]+') as int) + 100000000
		                  ELSE 100000000
		                END`).
		                Scopes(Paginate(c)).
		                Find(&cards)

		if result.Error != nil {
			log.Fatal(result.Error)
		}
		offset, exists := c.Get("offset")
		if !exists {
			log.Fatal(errors.New("Couldn't find offset in context"))
		}

		pagedSearchResult := SearchResult{
			PagedResult: NewPagedResult(count, offset.(int64)),
			Cards: cards,
		}
		c.Header("Access-Control-Allow-Origin", "*")
		c.JSON(http.StatusOK, pagedSearchResult)
	}

type UpdateRequest struct {
	CardID uuid.UUID `json:"card_id"`
	Quantity int `json:"quantity"`
}

func updateCollection(c *gin.Context) {
	var dbUser models.User
	db.Model(&models.User{}).Select("id").Where("username = ?", c.Param("user")).First(&dbUser)

	var updateRequest UpdateRequest
	c.BindJSON(&updateRequest)
	collectionEntry := models.CollectionEntry {
		UserID: dbUser.ID,
		CardID: updateRequest.CardID,
		Quantity: updateRequest.Quantity,
	}

	// This is kind of complicated so here's the explanation
	// We create the collectionEntry, but on a conflict we
	// add the quantity of the existing column to the quantity
	// we were given. This gets wrapped in GREATEST(x, 0)
	// so it doesn't go below 0 clause.Returning{} ensures that we
	// put the value after resolving the conflict into &collectionEntry
	result := db.Clauses(
		clause.OnConflict{
			Columns: []clause.Column{{Name: "user_id"}, {Name: "card_id"}},
			DoUpdates: clause.Assignments(map[string]interface{}{
				"quantity": gorm.Expr("GREATEST(collection_entries.quantity + ?, 0)", collectionEntry.Quantity)})},
		clause.Returning{},
	).Create(&collectionEntry)
	if result.Error != nil {
		c.JSON(http.StatusUnauthorized, ErrorResponse{Message: "Error creating db entry"})
		return
	}

	c.JSON(http.StatusOK, collectionEntry)
}

func collectionGetCardsByID(c *gin.Context) {
	id := c.Param("id")
	username := c.Param("user")
	_, err := uuid.Parse(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrInvalidUUID.Error()})
		return
	}

	var collectionEntries []models.CollectionEntry
	err = db.Model(&models.CollectionEntry{}).
	          Joins("left join users on users.id = collection_entries.user_id").
	          Where("username = ?", username).
	          Where("card_id = ?", id).
	          Find(&collectionEntries).
	          Error
	if err != nil {
		log.Fatal(err)
	}

	c.JSON(http.StatusOK, collectionEntries)
}

func collectionPostEndpoint(c *gin.Context) {
	action := c.Param("action")
	if action == "update" {
		updateCollection(c)
	} else {
		errorMessage := fmt.Sprintf("Unknown action: %s", action)
		c.JSON(http.StatusBadRequest, ErrorResponse{Message: errorMessage})
	}
}

func ParseToken(tokenString string) (claims *Claims, err error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
	return jwtKey, nil
    })

    if err != nil {
	return nil, err
    }

    claims, ok := token.Claims.(*Claims)

    if !ok {
	return nil, err
    }

    return claims, nil
}

func TokenAuthRequired() gin.HandlerFunc {
	return func(c *gin.Context) {
		token, err := c.Cookie("token")
		if err != nil {
			// Probably not logged in
			// TODO: Forward to the login page or something instead of returning error
			obj := struct {
				Error string
			}{
				Error: "not logged in",
			}
			c.AbortWithStatusJSON(http.StatusUnauthorized, obj)
			return
		}

		claims, err := ParseToken(token)

		if err != nil {
			// TODO: Better error message
			c.AbortWithStatusJSON(http.StatusUnprocessableEntity, ErrUnknown.Error())
			return
		}

		username := c.Param("user")

		if claims.Subject != username {
			c.AbortWithStatusJSON(http.StatusUnauthorized, unauthorizedResponse)
			return
		}

		c.Next()
	}
}

func main() {
	var err error
	db, err = gorm.Open(postgres.Open(dsn), &gorm.Config{TranslateError: true})
	if err != nil {
		log.Fatal(err)
	}

	err = db.AutoMigrate(&models.Card{},
	                      &models.Set{},
	                      &models.Face{},
	                      &models.Finish{},
	                      &models.User{},
	                      &models.CollectionEntry{})
	if err != nil {
		log.Fatal(err)
	}

	r := setupRouter()	
	// Listen and Server in 0.0.0.0:8080
	r.Run(":8080")
}
