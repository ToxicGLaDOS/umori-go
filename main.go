package main

import (
	"context"
	//"encoding/json"
	"errors"
	"fmt"
	//"io"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/toxicglados/umori-go/pkg/crypto"
	"github.com/toxicglados/umori-go/pkg/models"

	"github.com/gin-gonic/gin"
	"github.com/shaj13/go-guardian/v2/auth"
	"github.com/shaj13/go-guardian/v2/auth/strategies/basic"
	"github.com/shaj13/go-guardian/v2/auth/strategies/jwt"
	"github.com/shaj13/libcache"
	_ "github.com/shaj13/libcache/fifo"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

const (
	pageSize = 25
)

var (
	db *gorm.DB
	dsn = "host=localhost user=postgres password=password dbname=postgres port=55432 TimeZone=America/Chicago"
	ErrUnexpectedEOF error = errors.New("Unexpected EOF")
	ErrUserAlreadyExists error = errors.New("That username already exists")
	ErrUnknown error = errors.New("Unknown error")
	ErrCreatingToken error = errors.New("Error creating token")
	ErrInvalidJSON error = errors.New("Invalid JSON body")
	ErrInvalidCredentials error = errors.New("Invalid credentials")
	ErrMissingBasicAuth error = errors.New("Request missing BasicAuth")
	ErrMalformedToken error = errors.New("Malformed JWT token")
	ErrInvalidToken error = errors.New("Invalid JWT token")
	ErrMissingKID error = errors.New("Token missing kid header. Provided JWT likely wasn't generated by this server")
	ErrInvalidUUID error = errors.New("Invalid UUID")

)
func GetOffset(c *gin.Context) int {
	page, err := strconv.Atoi(c.Query("page"))
	if err != nil || page < 0 {
		page = 0
	}
	offset := page * pageSize

	return offset
}

func Paginate(c *gin.Context) func(db *gorm.DB) *gorm.DB {
	return func (db *gorm.DB) *gorm.DB {
		offset := GetOffset(c)
		c.Set("offset", int64(offset))
		return db.Offset(offset).Limit(pageSize)
	}
}

type SearchResult struct {
	PagedResult
	Cards []models.Card `json:"results"`
}

type PagedResult struct {
	HasMore bool `json:"has_more"`
}

func NewPagedResult(count, offset int64) PagedResult {
	return PagedResult {
		HasMore: count - (offset + pageSize) > 0,
	}
}

type ErrorResponse struct {
	Message string `json:"message"`
}

var (
	jwtStrategy auth.Strategy
	basicStrategy auth.Strategy
	keeper jwt.SecretsKeeper
	cacheObj libcache.Cache
	unauthorizedResponse ErrorResponse = ErrorResponse{Message: "Unauthorized"}
)

func setupRouter() *gin.Engine {
	// Disable Console Color
	// gin.DisableConsoleColor()
	r := gin.Default()


	basicAuthorized := r.Group("/api")
	basicAuthorized.Use(BasicAuthRequired())
	{
		basicAuthorized.GET("/token", tokenEndpoint)
	}

	tokenAuthorized := r.Group("/api")
	tokenAuthorized.Use(TokenAuthRequired())
	{
		tokenAuthorized.POST("/:user/collection/:action", collectionPostEndpoint)
		tokenAuthorized.GET("/:user/collection/cards/:id", collectionGetCardsByID)
		// Token auth functions go here
	}

	r.GET("/api/cards/search", searchEndpoint)

	r.POST("/api/register", registerEndpoint)
	r.POST("/api/login", loginEndpoint)

	return r
}

func loginEndpoint(c *gin.Context) {
	var form models.UnsafeUser
	// This will infer what binder to use depending on the content-type header.
	if err := c.ShouldBind(&form); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var user models.User
	db.Model(&models.User{}).Select("PasswordHash").Where("username = ?", form.Username).First(&user)
	match, err := crypto.ComparePasswordAndHash(*form.Password, user.PasswordHash)

	if match {
		c.JSON(http.StatusOK, gin.H{"status": "you are logged in"})
		return
	} else {
		if err != nil {
			// TODO: Probably shouldn't return this error to the user directly, not sure what it includes
			c.JSON(http.StatusUnauthorized, gin.H{"status": fmt.Sprintf("unauthorized: %s", err.Error())})
		}
		c.JSON(http.StatusUnauthorized, gin.H{"status": "unauthorized"})
		return
	} 
	
}

func registerEndpoint(c *gin.Context) {
		var unsafeUser models.UnsafeUser

		err := c.ShouldBind(&unsafeUser)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}
		passwordHash, err := crypto.GenerateFromPassword(*unsafeUser.Password, crypto.DefaultHashingParams())

		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
		}

		var user = models.User{
			Username: *unsafeUser.Username,
			PasswordHash: passwordHash,
		}

		//err := c.BindJSON(&user)
		//if err != nil {
		//	if errors.Is(err, io.EOF) {
		//		c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrUnexpectedEOF.Error()})
		//	} else {
		//		var unmarshalTypeError *json.UnmarshalTypeError
		//		var syntaxError *json.SyntaxError
		//		if errors.As(err, &unmarshalTypeError) {
		//			c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrInvalidJSON.Error()})
		//		} else if errors.Is(err, models.ErrMissingPassword) || errors.Is(err, models.ErrMissingUsername) || errors.As(err, &syntaxError) {	
		//			c.JSON(http.StatusBadRequest, ErrorResponse{Message: err.Error()})
		//		} else {
		//			c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrUnknown.Error()})
		//		}
		//	}
		//	return
		//}

		err = db.Create(&user).Error

		if err != nil {
			if errors.Is(err, gorm.ErrDuplicatedKey) {
				c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrUserAlreadyExists.Error()})
			} else {
				// I'm not sure what could cause this
				log.Printf("Got unexpected error during user creation: \"%s\"\n", err.Error())
				c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrUnknown.Error()})
			}
			return
		}

		c.JSON(http.StatusOK, struct{}{})
	}

func searchScope(nameContains string, defaultOnly, includeDigitalExclusive bool) func(db *gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		result := db.Model(&models.Card{}).
		             Where("name ILIKE ?", nameContains)
		if defaultOnly {
			result = result.Where("default_lang = true")
		}
		if !includeDigitalExclusive {
			result = result.Where("digital_exclusive = false")
		}
		return result
	}
}

func searchEndpoint(c *gin.Context) {
		// nameContains is never empty because of the %%
		// so even without a parameter we will search for everything
		nameContains := fmt.Sprintf("%%%s%%", c.Query("nameContains"))
		defaultOnly := c.Query("defaultOnly") == "true"
		collapsePrintings := c.Query("collapsePrintings") == "true"
		includeDigitalExclusive := c.Query("includeDigitalExclusive") == "true"

		// collapsePrintings implies defaultOnly
		if collapsePrintings {
			defaultOnly = true
		}

		// Get count for query
		var count int64
		result := db.Model(&models.Card{}).
		            Scopes(searchScope(nameContains, defaultOnly, includeDigitalExclusive))

		if collapsePrintings {
			result = result.Distinct("name")
		}
		err := result.Count(&count).
		              Error
		if err != nil {
			log.Fatal(err)
		}

		// Get rows for query
		var cards []models.Card
		result = db.Model(&models.Card{}).
		            Preload("Set").
		            Preload("Finishes").
		            Preload("Faces").
		            Scopes(searchScope(nameContains, defaultOnly, includeDigitalExclusive))

		if collapsePrintings {
			// This is a postgres exclusive trick
			result = result.Select("DISTINCT ON (name) *")
		}

		// The collector_number sorting is a bit wild
		// We check if it's a number and then cast it to a number
		// if not, then we try to find a substring that's an number
		// and cast that to a number and add a large number to
		// preserve the order of non-numeric collector_numbers while still
		// making it larger than any numeric one.
		// lastly, if there are no numbers in the collector_number we just make it a large number
		// Of course this happens after the other searches so it's rarely relevant
		result = result.Order("name").
		                Order(`
		                CASE
		                  WHEN language = 'en' THEN 0
		                  ELSE 1
		                END`).
		                Order("release_date desc").
		                Order("default_lang desc").
		                Order(`
		                CASE
		                  WHEN collector_number ~ '^[0-9]+$' THEN cast(collector_number as int)
		                  WHEN collector_number ~ '[0-9]+' THEN cast(substring(collector_number from '[0-9]+') as int) + 100000000
		                  ELSE 100000000
		                END`).
		                Scopes(Paginate(c)).
		                Find(&cards)

		if result.Error != nil {
			log.Fatal(result.Error)
		}
		offset, exists := c.Get("offset")
		if !exists {
			log.Fatal(errors.New("Couldn't find offset in context"))
		}

		pagedSearchResult := SearchResult{
			PagedResult: NewPagedResult(count, offset.(int64)),
			Cards: cards,
		}
		c.Header("Access-Control-Allow-Origin", "*")
		c.JSON(http.StatusOK, pagedSearchResult)
	}

type UpdateRequest struct {
	CardID uuid.UUID `json:"card_id"`
	Quantity int `json:"quantity"`
}

func updateCollection(c *gin.Context) {
	var dbUser models.User
	db.Model(&models.User{}).Select("id").Where("username = ?", c.Param("user")).First(&dbUser)

	var updateRequest UpdateRequest
	c.BindJSON(&updateRequest)
	collectionEntry := models.CollectionEntry {
		UserID: dbUser.ID,
		CardID: updateRequest.CardID,
		Quantity: updateRequest.Quantity,
	}

	// This is kind of complicated so here's the explanation
	// We create the collectionEntry, but on a conflict we
	// add the quantity of the existing column to the quantity
	// we were given. This gets wrapped in GREATEST(x, 0)
	// so it doesn't go below 0 clause.Returning{} ensures that we
	// put the value after resolving the conflict into &collectionEntry
	result := db.Clauses(
		clause.OnConflict{
			Columns: []clause.Column{{Name: "user_id"}, {Name: "card_id"}},
			DoUpdates: clause.Assignments(map[string]interface{}{
				"quantity": gorm.Expr("GREATEST(collection_entries.quantity + ?, 0)", collectionEntry.Quantity)})},
		clause.Returning{},
	).Create(&collectionEntry)
	if result.Error != nil {
		c.JSON(http.StatusUnauthorized, ErrorResponse{Message: "Error creating db entry"})
		return
	}

	c.JSON(http.StatusOK, collectionEntry)
}

func collectionGetCardsByID(c *gin.Context) {
	id := c.Param("id")
	username := c.Param("user")
	_, err := uuid.Parse(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrInvalidUUID.Error()})
		return
	}

	var collectionEntries []models.CollectionEntry
	err = db.Model(&models.CollectionEntry{}).
	          Joins("left join users on users.id = collection_entries.user_id").
	          Where("username = ?", username).
	          Where("card_id = ?", id).
	          Find(&collectionEntries).
	          Error
	if err != nil {
		log.Fatal(err)
	}

	c.JSON(http.StatusOK, collectionEntries)
}

func collectionPostEndpoint(c *gin.Context) {
	action := c.Param("action")
	if action == "update" {
		updateCollection(c)
	} else {
		errorMessage := fmt.Sprintf("Unknown action: %s", action)
		c.JSON(http.StatusBadRequest, ErrorResponse{Message: errorMessage})
	}
}

func tokenEndpoint(c *gin.Context) {
	token, err := createToken(c.Request)
	if err != nil {
		log.Printf("Error creating token: \"%s\"\n", err)
		c.JSON(http.StatusBadRequest, ErrorResponse{Message: ErrCreatingToken.Error()})
		return
	}

	c.JSON(http.StatusOK, struct{Token string}{Token: token})
}

func setupGoGuardian() {
	keeper = jwt.StaticSecret{
		ID:        "secret-id",
		Secret:    []byte("secret"),
		Algorithm: jwt.HS256,
	}
	cacheObj = libcache.FIFO.New(0)
	cacheObj.SetTTL(time.Minute * 1)
	basicStrategy = basic.NewCached(validateUser, cacheObj)
	jwtStrategy = jwt.New(cacheObj, keeper)
}

func createToken(r *http.Request) (string, error) {
	u := auth.User(r)
	token, err := jwt.IssueAccessToken(u, keeper)
	return token, err
}

// Only called if user isn't found in cacheObj
func validateUser(ctx context.Context, r *http.Request, userName, password string) (auth.Info, error) {
	var dbUser models.User
	err := db.Select("PasswordHash").Where("username = ?", userName).First(&dbUser).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, ErrInvalidCredentials
		} else {
			return nil, ErrUnknown
		}
	}


	match, err := crypto.ComparePasswordAndHash(password, dbUser.PasswordHash)
	if err != nil {
		log.Fatal(err)
	}

	if match {
		// I honestly don't know what the second parameter
		// "id" does here. Keeping it as a literal "1" didn't
		// seem to matter, but we set it to the userID just to
		// ensure it's different per user in case that matters
		return auth.NewDefaultUser(userName, strconv.FormatUint(uint64(dbUser.ID), 10), nil, nil), nil
	}

	// This is a little weird because validateUser doesn't have
	// anything to do with basic auth necessarily, but that's all
	// we use to call this function.
	// This makes it so the errors are the same whether the
	// user was found in cache or not
	return nil, basic.ErrInvalidCredentials
}

func BasicAuthRequired() gin.HandlerFunc {
	return func(c *gin.Context) {
		user, err := basicStrategy.Authenticate(c.Request.Context(), c.Request)
		if err != nil {
			if errors.Is(err, basic.ErrMissingPrams) {
				errorResponse := ErrorResponse{
					Message: ErrMissingBasicAuth.Error(),
				}
				c.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse)
			} else if errors.Is(err, basic.ErrInvalidCredentials) {
				errorResponse := ErrorResponse{
					Message: ErrInvalidCredentials.Error(),
				}
				c.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse)
			} else {
				errorResponse := ErrorResponse{
					Message: err.Error(),
				}
				fmt.Printf("got error when authenticating: %s\n", err.Error())
				c.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse)
			}

			return
		}

		// This is critical because we pull the user out in
		// createToken
		c.Request = auth.RequestWithUser(user, c.Request)
		c.Next()
	}
}

func TokenAuthRequired() gin.HandlerFunc {
	return func(c *gin.Context) {
		user, err := jwtStrategy.Authenticate(c.Request.Context(), c.Request)
		if err != nil {
			errorResponse := ErrorResponse{}
			if strings.Contains(err.Error(), "compact JWS format must have three parts") {
				errorResponse.Message = ErrMalformedToken.Error()
			} else if errors.Is(err, jwt.ErrMissingKID) {
				errorResponse.Message = ErrMissingKID.Error()
				// We treat these conditions the same because one indicates the
				// token isn't signed with the correct secret and the other
				// indicates the token is valid, but for a different user
				// and we don't want to leak that information
			} else if strings.Contains(err.Error(), "error in cryptographic primitive") ||
			          strings.Contains(err.Error(), "Invalid token") {
				errorResponse.Message = ErrInvalidToken.Error()
			} else {
				fmt.Printf("got unexpected error when authenticating: %s\n", err)
				errorResponse.Message = ErrUnknown.Error()
			}
			c.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse)
			return
		}

		username := c.Param("user")

		if user.GetUserName() != username {
			c.AbortWithStatusJSON(http.StatusUnauthorized, unauthorizedResponse)
			return
		}

		// This is critical because we pull the user out in
		// createToken
		c.Request = auth.RequestWithUser(user, c.Request)
		c.Next()
	}
}

func main() {
	var err error
	db, err = gorm.Open(postgres.Open(dsn), &gorm.Config{TranslateError: true})
	if err != nil {
		log.Fatal(err)
	}

	err = db.AutoMigrate(&models.Card{},
	                      &models.Set{},
	                      &models.Face{},
	                      &models.Finish{},
	                      &models.User{},
	                      &models.CollectionEntry{})
	if err != nil {
		log.Fatal(err)
	}

	setupGoGuardian()

	r := setupRouter()	
	// Listen and Server in 0.0.0.0:8080
	r.Run(":8080")
}
